# Table is a list of dicts, where each dict represents a row, with keys corresponding to column names
# and values to the respective entries in the table

import "List.ae";

type Table;
type Row;

# Reads a CSV file and returns a Table.
# path: path to the CSV file
# returns: table loaded from the CSV file
def Table_from_csv(path: String): Table {
    native "__import__('pandas').read_csv(path).to_dict('records')"
}

# Writes a Table to a CSV file.
# table: the table to write
# path: path to the output CSV file
def Table_to_csv(table: Table) (path: String): Unit {
    native "__import__('pandas').DataFrame(table).to_csv(path, index=False)"
}

# Returns the list of column names in the table.
# table: the table to inspect
# returns: list of column names
def Table_columns(table: Table): (List String) {
    native "list(table[0].keys()) if len(table) > 0 else []"
}

# Selects a subset of columns from the table.
# table: the table to select from
# columns: columns to select
# returns: new table with only the selected columns
def Table_select(table: Table) (columns: (List String)): Table {
    native "[{col: row[col] for col in columns} for row in table]"
}

# Filters rows in the table using a predicate function.
# table: the table to filter
# predicate: function to decide if a row is kept
# returns: filtered table
def Table_filter(table: Table) (predicate: (row: Row) -> Bool): Table {
    native "[row for row in table if predicate(row)]"
}

# Applies a function to a column in all rows.
# table: the table to modify
# column: column to modify
# f: function to apply to each value in the column
# returns: table with updated column values
def Table_map_column(table: Table) (column: String) (f: (a: t) -> b): Table {
    native "[dict(row, **{column: f(row[column])}) for row in table]"
}

# Applies a summary function to a column in the table.
# table: the table to summarize
# column: column to summarize
# f: summary function (e.g., sum, mean)
# returns: result of the summary function
def Table_summary(table: Table) (column: String) (f: (a: (List Int)) -> b): b {
    native "f([row[column] for row in table])"
}

# Groups the table by a column, returning a list of tables (one per group).
# - For each unique value in the specified column, creates a group (table) of all rows with that value.
# table: the table to group
# column: column to group by
# returns: list of tables, each corresponding to a group
def Table_group_by(table: Table) (column: String): (List Table) {
    native "__import__('aeon.aeon.bindings.table').aeon.aeon.bindings.table.group_by(table, column)"
}

# Pivots a table: turns unique values from one column into new columns.
# - For each unique value in the `index` column of the input table, create a row in the output table.
# - For each unique value in the `columns` column, create a new column in the output table.
# - For each original row, place its value from the `values` column at the intersection defined by its `index` and `columns` values.
# table: the table to pivot
# index: column to use as row index
# columns: column whose unique values become new columns
# values: column to fill values from
# returns: reshaped table (list of dicts)
def Table_pivot(table: Table) (index: String) (columns: String) (values: String): Table {
    native "__import__('aeon.aeon.bindings.table').aeon.aeon.bindings.table.pivot(table, index, columns, values)"
}

# Melts a table: turns columns into rows (unpivot).
# - For each row in the input table, and for each column in value_vars, creates a new row.
# - The new row contains all id_vars, the name of the melted column, and its value.
# table: the table to melt
# id_vars: columns to keep as identifiers
# value_vars: columns to unpivot
# var_name: name for the new variable column
# value_name: name for the new value column
# returns: reshaped table (list of dicts)
def Table_melt(table: Table) (id_vars: (List String)) (value_vars: (List String)) (var_name: String) (value_name: String): Table {
    native "__import__('aeon.aeon.bindings.table').aeon.aeon.bindings.table.melt(table, id_vars, value_vars, var_name, value_name)"
}
